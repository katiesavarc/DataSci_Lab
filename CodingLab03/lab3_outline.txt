1) somehow make a grid that represents our pixels( each 1x1 will be our "pixel box")

1.12) plot the image with the "objects" (scatter plot) input(d,data_arr(Nx2))

2) randomilly generate "objects" into the grid

- generate objects 2d coord inside our sized grid

- Noah has code that will tell how many objects fall within one pixel(histo version)
2.1) Generate_Stars([x-range], [y-range], N(number od objects wanted)) -> data_arr(Nx2)

3) standard deviation give by sigma = sqrt( mean # of stars per period(?))
3.1) Calc_STD(d_arr) -> std_array();

4) sigma = 1\d, we can find our d


5) change the pixels size to change the d

Want to use the same data as before, just want to change the pixel size
Make the biggest grid d = 1, then when scaling down should fall as ~r^2 
same number pixels, smaller area 

5.1) func that takes in the new bounds and filter out objects not inside the wanted
bounds


FINAL)
plot - sigma(1/D) for different scale changes
plot - 3D histogram for a d, use two/three different d to show how the bins are different


Group work:

- grid and generate objects -> plot of the grid and save the data as 2 (Nx1) array -INGRID 
input (d, 
output: two Nx1 array of coordinate for objects (x,y) 

- histugram function plots (check that number of elements is greater than bins) -NOAh
- extra funct(d) -> (xlim, ylim) you take that xlim and ylim and divide by numpixels to get pixel 
sub bounds
input: (d,x_array,y_array)
output:  [list of edges of bins, array of value in each bin]

- STD calculations and plotting the final 'clean' plots -KATIE
input: (array of value in each bin)
*loop it over different distances*
output: our graphs plz

+main function that starts


extensions to think about:
Different lum per object
if time, make objects into point spread functions

